const path = require('path');

function isRate(time){
	if (time == '*'){
		return true;
	}
	for (i in time){
		if (time[i] == '/'){
			return true;
		}
	}
	return false;
}

function getRate(time){
	var rateTime = '';
	var rate = ['',''];
	var i = 0;

	if (time == '*' || time == '*/' || time == '0/' || time == '0/1' || time == '*/1'){
		return ['0','1'];
	}
	while (time[i] != '/'){
		rate[0]+=time[i];
		i++;
	}
	while (++i < time.length){
		rate[1]+=time[i]
	}
	return rate;
}
/*
changeRate changes rates in cases where the previous entries were their minimum value
ex: 0 0 0 2/4 ? * -> 59 23 L 1/4 ? *
    0 0 0 1/4 ? * -> 59 23 L 4/4 ? *
    0 /5 * * ? *  -> 59 4/5 * * ? * (this example skips the first event)
returns the adjusted rate as a couple
*/
function changeRate(rate, type){
	// if not a special case, subtract 1
	if (rate[0] != '*' && rate[0] != '0' && rate[0] != ''){
		// type 0 has a range starting at 0
		// type 1 has a range starting at 1
		if (type == 0 || type == 1 && rate[0]-'0'>1){
			// if starting point > min, subtract 1
			rate[0] = ((rate[0]-'0')-1).toString();
		}
		// if rate[0] == '1' and type == 1
		else{
			// this will skip the first event
			// will need to create an alternative event
			rate[0] = rate[1];
		}
	}
	// otherwise, rate[0] will be a minumum value
	else{	
		if (rate != ['*',''] && rate[1] != '0'){
		
			if (type == 1){
				rate[0] = rate[1];
			}
			else{
				rate[0] = ((rate[1]-'0') - 1).toString();
			}
		}
		// this is the minimum rate; does not change
		else{
			// */, /0, */0, */1 all result in the same output
			// */1 works for all entries
			rate = ['*','1'];
		}
	}
	return rate;
}

/* not utilized yet
function isRange(time){
	for(var i in time){
		if (i == '-'){
			return true;
		}
	}
	return false;
}

function getRange(tarr, type){
	var rangeTime = ['',''];
	var i = 0;
	while(time[tarr][i] != '-'){
		rangeTime[0] += time[i];
		i++;
	}
	while(i < time.length){
		rangeTime[1] += time[i];
		i++;
	}
}
*/

function changeSchedule(funcEv){
	var newFuncEv = [];
	// lists number of days in month
	// if month is not specified, 0 index is default value of 28 
	// this way cron will not go out of bounds but up to 3 events may be missed
	for (schedule in funcEv){
		var cron = Object.values(funcEv[schedule])[0];
		console.log("Next Event:");
		console.log(cron);
		
		if (cron.slice(0,4) == 'cron'){
			var entry = 1; // 6 entries in Amazon CRON syntax
			var i = 5; // index of first entry in cron
			var curEn = '';
			var remainder = '';

			var len = cron.length;
			var min = '*', hr = '*', dom = '?', mnth = '*', dow = '?', yr = '*';
			
			while (entry < 7 && i < len){
				if (cron[i] != ' ' && cron[i] != ')'){
					curEn += cron[i];
				}
				else{
					switch(entry){
						case 1:
							min = curEn;
							break;
						case 2:
							hr = curEn;
							break;
						case 3:
							dom = curEn;
							break;
						case 4:
							mnth = curEn;
							break;
						case 5:
							dow = curEn;
							break;
						case 6:
							yr = curEn;
					}
					curEn = '';
					entry++
				} // end else
				i++;
			} // end while

			if (isRate(min)){
				var rate = getRate(min);
				// only change rate if the rate is over 6 minutes
				// otherwise, the system will always be warm anyway
				if (rate[1] !='' && rate[1]-'0'>6){
					rate = changeRate(rate,0);
					min = rate[0]+'/'+rate[1];
					var newCron = 'cron('+min+' '+hr+' '+dom+' '+mnth+' '+dow+' '+yr+')';
					newFuncEv.push({'schedule':newCron});
				}
			}
			else if (isRate(hr)){
				// get rid of rate = getRate(time)
				// put in else statement
				var rate = getRate(hr);
				if (min-'0'>0){
					min = ((min-'0')-1).toString();
				}
				else{
					// rate = changeRate(getRate(hr),0);
					rate = changeRate(rate,0);
					hr = rate[0]+'/'+rate[1];
					min = '59';
				}
				
				var newCron = 'cron('+min+' '+hr+' '+dom+' '+mnth+' '+dow+' '+yr+')';
				newFuncEv.push({'schedule':newCron});
			}
			else if (isRate(dom)){
				var rate = getRate(dom);
				if (min-'0'>0){
					min = ((min-'0')-1).toString();
				}
				else if (hr-'0'>0){
					hr = ((hr-'0')-1).toString();
					min = '59';
				}
				else{
					rate = changeRate(rate,1);
					dom = rate[0]+'/'+rate[1];
					hr = '23';
					min = '59';
				}
						
				var newCron = 'cron('+min+' '+hr+' '+dom+' '+mnth+' '+dow+' '+yr+')';
				newFuncEv.push({'schedule':newCron});
			}
			else if (isRate(mnth)){
				rate = getRate(mnth);

				if (min-'0'>=1){
					min = ((min-'0')-1).toString();
				}
				else if (hr-'0' >= 1){
					hr = ((hr-'0')-1).toString();
					min = '59';
				}
				else if (dom-'0'>1 && dom != '?' || dow-'0'>1 && dom != '?'){
					if (dom-'0'>1 && dom != '?'){
						dom = ((dom-'0')-1).toString();
						dow = '?';
					}

					else if (dow-'0'>1 && dow != '?'){
						dow = ((dow-'0')-1).toString();
						dom = '?';
					}
					hr = '23';
					min = '59';
				}
				else{
					rate = changeRate(rate,1);

					if (dom-'0'>=1 && dom != '?'){
						dom = 'L';
						dow = '?';
					}
					else if (dom-'0'>=1 && dom != '?'){
						dow = 'L';
						dom = '?';
					}

					mnth = rate[0]+'/'+rate[1];
					hr = '23';
					min = '59';
				}
				
				var newCron = 'cron('+min+' '+hr+' '+dom+' '+mnth+' '+dow+' '+yr+')';
				newFuncEv.push({'schedule':newCron});
			}

			// Amazon does not support '/' rates for dow

			else if (isRate(yr)){
				rate = getRate(yr);
				if (min-'0'>=1){
					min = ((min-'0')-1).toString();
				}
				else if (hr-'0'>= 1){
					hr = ((hr-'0')-1).toString();
					min = '59';
				}
				else if (dom-'0'>1 && dom != '?' || dow-'0'>1 && dom != '?'){
					if (dom-'0'>1 && dom != '?'){
						dom = ((dom-'0')-1).toString();
						dow = '?';
					}

					else if (dow-'0'>1 && dow != '?'){
						dow = ((dow-'0')-1).toString();
						dom = '?';
					}
					hr = '23';
					min = '59';
				}
				else if (mnth-'0'>1){
					mnth = ((mnth-'0')-1).toString();
					if (dom-'0'>=1 && dom != '?'){
						dom = 'L';
						dow = '?';
					}
					else if (dom-'0'>=1 && dom != '?'){
						dow = 'L';
						dom = '?';
					}

					hr = '23';
					min = '59';
				}
				else{
					rate = changeRate(rate,1);
					yr = rate[0]+'/'+rate[1];
					mnth = '12';
					if (dom-'0'>=1 && dom != '?'){
						dom = 'L';
						dow = '?';
					}
					else if (dom-'0'>=1 && dom != '?'){
						dow = 'L';
						dom = '?';
					}
					
					hr = '23';
					min = '59';	
				}
				
				var newCron = 'cron('+min+' '+hr+' '+dom+' '+mnth+' '+dow+' '+yr+')';
				newFuncEv.push({'schedule':newCron});
			}
			else { // is not rate
				if (min-'0'>=1){
					min = ((min-'0')-1).toString();
				}
				else if (hr-'0' >= 1){
					min = '59';
					hr = ((hr-'0')-1).toString();
				}
				else if (dom-'0'>1 && dom != '?' || dow-'0'>1 && dow != '?'){
					min = '59';
					hr = '23';
					if (dom-'0'>1 && dom != '?'){
						dom = ((dom-'0')-1).toString();
						dow = '?';
					}
					if (dow-'0'>1 && dow != '?'){
						dow = ((dow-'0')-1).toString();
						dom = '?';
					}
				}
				else if (mnth-'0'>1){
					min = '59';
					hr = '23';
					dom = 'L';
					mnth = ((mnth-'0')-1).toString();
					dow = '?';
				}
				else{
					min = '59';
					hr = '23';
					dom = 'L';
					mnth = '12';
					dow = '?';
					// adds current year in order to be valid cron expression
					// to be modified
					yr = ((yr-'0')-1).toString();		
										
				}
				var newCron = 'cron('+min+' '+ hr+' '+dom+' '+mnth+' '+dow+' '+yr+')';
				newFuncEv.push({'schedule':newCron});
	
			}		
		} // end if
	} // end loop
	console.log(newFuncEv);
	return newFuncEv;
}



// obtain proper events for the warmer function
// prioritizes base events for warmer 
// returns array[] of {schedule}
function getSchedule(service, ev, defaultOpts){
	// create an array of function keys
	func = Object.keys(service.functions);

	var fEvent = []; // array will contain function events 

	// if the warmer has its own events, use them
	if (Array.isArray(ev)){
			fEvent = ev;
	}

	//  otherwise, check if there is more than one function
	else if (func.length == 1){ 

		// translate function name into a string evaluation 
		// now we can write service.functions.func.events
		str = "var x = service.functions." + func + ".events";
		eval(str);
		// add all schedule events to fEvent
		var isEv = false;
		for (var evnt in x) {
			if (Object.keys(x[evnt]) == 'schedule'){
				isEv = true;
				fEvent.push(x[evnt]);
			}
		}
		// fEvent now contains all function events
		// change events to be one minute behind the original function event
		if (!isEv){
			return defaultOpts.events;
		}
		fEvent = changeSchedule(fEvent);
		
	}
	// otherwise, use defaults
	else{
		fEvent = defaultOpts.events;
	}
	return fEvent;
}

/**
 * @description Clean a global configuration object
 * and fill the missing options using the given defaults
 *
 * @return {Object} - Global configuration options
 * */
function getWarmerConfig(config, defaultOpts, service) { // service was added to parameter
  const folderName = path.join((typeof config.folderName === 'string') ? config.folderName : defaultOpts.folderName);

	

	
fEvent = getSchedule(service, config.events, defaultOpts);

  /* eslint-disable no-nested-ternary */
  return {
    folderName,
    pathHandler: `${folderName}/index.warmUp`,
    cleanFolder: (typeof config.cleanFolder === 'boolean') ? config.cleanFolder : defaultOpts.cleanFolder,
    name: (config.name !== undefined) ? config.name : defaultOpts.name,
    role: (config.role !== undefined) ? config.role : defaultOpts.role,
    tags: (config.tags !== undefined) ? config.tags : defaultOpts.tags,
    vpc: config.vpc === false ? { securityGroupIds: [], subnetIds: [] }
      : (config.vpc !== undefined ? config.vpc : defaultOpts.vpc),

    events: fEvent,
    package: typeof config.package === 'object'
      ? {
        individually: (config.package.individually !== undefined)
          ? config.package.individually
          : defaultOpts.package.individually,
        exclude: Array.isArray(config.package.exclude)
          ? config.package.exclude
          : defaultOpts.package.exclude,
        include: Array.isArray(config.package.include)
          ? (config.package.include.includes(`${folderName}/**`)
            ? config.package.include
            : [...config.package.include, `${folderName}/**`])
          : [...defaultOpts.package.include, `${folderName}/**`],
      }
      : {
        ...defaultOpts.package,
        include: [...defaultOpts.package.include, `${folderName}/**`],
      },
    memorySize: (config.memorySize !== undefined) ? config.memorySize : defaultOpts.memorySize,
    timeout: (config.timeout !== undefined) ? config.timeout : defaultOpts.timeout,
    environment: (config.environment !== undefined)
      ? config.environment
      : defaultOpts.environment,
    tracing: (config.tracing !== undefined) ? config.tracing : defaultOpts.tracing,
    prewarm: (config.prewarm !== undefined) ? config.prewarm : defaultOpts.prewarm,
  };
  /* eslint-enable no-nested-ternary */
}

/**
 * @description Clean a function-specific configuration object
 * and fill the missing options using the given defaults
 *
 * @return {Object} - Function-specific configuration options
 * */
function getFunctionConfig(config, defaultOpts) {
  /* eslint-disable no-nested-ternary */
  return {
    enabled: (config.enabled !== undefined)
      ? config.enabled
      : defaultOpts.enabled,
    alias: (config.alias !== undefined)
      ? config.alias
      : defaultOpts.alias,
    clientContext: (config.clientContext !== undefined)
      ? config.clientContext && JSON.stringify(config.clientContext)
      : defaultOpts.clientContext,
    payload: (config.payload !== undefined)
      ? (config.payloadRaw ? config.payload : JSON.stringify(config.payload))
      : defaultOpts.payload,
    concurrency: (config.concurrency !== undefined)
      ? config.concurrency
      : defaultOpts.concurrency,
  };
  /* eslint-enable no-nested-ternary */
}

/**
 * @description After package initialize hook. Create warmer function and add it to the service.
 *
 * @return {Array} - List of functions to be warmed up and their specific configs
 * */
function getFunctionsByWarmer(service, stage, configsByWarmer) {
  // function contains all functions 
  /* 
   * the code below would look like functions.map.map or functions.name.config
   * this effectively searches all functions and their names
   */
  const functions = service.getAllFunctions()
    .map((name) => service.getFunction(name)) // creating a map that contains all names of functions
    .map((config) => { // creating a map that contains all configurations of those functions
      if (config.warmup === undefined) { // uses the config to check if function does not have a warmer
        return { 
          name: config.name,
          config: Object.entries(configsByWarmer)
            .reduce((warmers, [warmerName, warmerConfig]) => ({ // combines and reformats config
              ...warmers, // ... collects any number of arguments; similar to **argv in c main() parameter
              [warmerName]: getFunctionConfig({}, warmerConfig),
            }), {}),
        }; 
      }
      // begins search for unknown warmers and throws error if any exist
      const unknownWarmers = Object.keys(config.warmup)
        .filter((warmerName) => configsByWarmer[warmerName] === undefined);
      if (unknownWarmers.length > 0) {
        throw new Error(`WarmUp: Invalid function-level warmup configuration (${unknownWarmers.join(', ')}) in function ${config.name}. Every warmer should be declared in the custom section.`);
      }
      // our function should go through here due to yml file
      return {
        name: config.name,
        config: Object.entries(configsByWarmer)
          .reduce((warmers, [warmerName, warmerConfig]) => ({
            ...warmers, 
            [warmerName]: getFunctionConfig(config.warmup[warmerName] || {}, warmerConfig),
          }), {}),
      };
    }); // config complete at this point

  function isEnabled(enabled) {
    return enabled === true
        || enabled === 'true'
        || enabled === stage
        || (Array.isArray(enabled) && enabled.indexOf(stage) !== -1);
  }

  // if warmers are properly allocated, the function will return here
  return functions.reduce((warmersAcc, fn) => { // fn is the function, warmersAcc is an accumulation
    Object.entries(fn.config)
      // checks to see if the correlating warmer is enabled within the function configurations
      .forEach(([warmerName, config]) => {
        if (!isEnabled(config.enabled)) return;
        // eslint-disable-next-line no-param-reassign
        if (!warmersAcc[warmerName]) warmersAcc[warmerName] = [];
        warmersAcc[warmerName].push({ name: fn.name, config });
      });
    // to access this {Array} after function call, try <variableName>[warmerName].name.config
    return warmersAcc; 
  }, {});
}


/**
 * @description Configure the plugin based on the context of serverless.yml
 *
 * @return {Object} - Configuration options to be used by the plugin
 * */
function getConfigsByWarmer(service, stage) {
  const getWarmerDefaultOpts = (warmerName) => ({
    folderName: path.join('.warmup', warmerName),
    cleanFolder: true,
    memorySize: 128,
    name: `${service.service}-${stage}-warmup-plugin-${warmerName}`,

    //events: [{ schedule: 'rate(5 minutes)' }], // 6 minutes was found to be more efficient
    // These are default events. The YAML file dictates the actual event
    //events: (Array.isArray(service.functions.schedule_test.events) ? service.functions.schedule_test.events : [{ schedule: 'rate(6 minutes)' }],

    events: [{ schedule: 'rate(6 minutes)' }],
    package: {
      individually: true,
      // Negating the includes to work around https://github.com/serverless/serverless/issues/8093
      include: service.package && service.package.include
        ? service.package.include
          .filter((pattern) => !pattern.startsWith('!'))
          .map((pattern) => `!${pattern}`)
        : [],
      exclude: ['**'],
    },
    timeout: 10,
    environment: Object.keys(service.provider.environment || [])
      .reduce((obj, k) => ({ ...obj, [k]: undefined }), {}),
    prewarm: false,
  });

  const functionDefaultOpts = {
    enabled: false,
    clientContext: undefined,
    payload: JSON.stringify({ source: 'serverless-plugin-warmup' }),
    concurrency: 1,
  };

  // configurations of the warmer
  // looks to see if there is a service.custom and adds it if there is
  const configsByWarmer = Object.entries(service.custom ? service.custom.warmup : {})
    // reformats the configurations of each warmer
    .reduce((warmers, [warmerName, warmerConfig]) => ({
      ...warmers,
      [warmerName]: {
        ...getWarmerConfig(warmerConfig, getWarmerDefaultOpts(warmerName), service),
        ...getFunctionConfig(warmerConfig, functionDefaultOpts),
      },
    }), {});

  /* we need access to the actual functions 
  functionsByWarmer returns the warmers and their configs
  we want the functions that getFunctionsByWarmer accesses


*/
  const functionsByWarmer = getFunctionsByWarmer(service, stage, configsByWarmer);

  //const functionsByWarmer = setSchedule(configsByWarmer, getFunctionsByWarmer(service, stage, configsByWarmer));


  return Object.entries(configsByWarmer).reduce((warmers, [warmerName, warmerConfig]) => ({
    ...warmers,
    [warmerName]: {
      ...warmerConfig,
      functions: functionsByWarmer[warmerName] || [],
    },
  }), {});
}

module.exports = {
  getConfigsByWarmer,
};
